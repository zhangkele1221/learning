/**********************************************
 > File Name: 19_MiirrorOfBinaryTree.cpp
 > Author: ZY
 > Created Time: 2017年03月27日 星期一 10时50分58秒
*******************************************/


#include<iostream>
#include<deque>
#include<stdio.h>

using namespace std;


struct BinaryTreeNode
{
	int  m_nValue;
	BinaryTreeNode*  m_pLeft;
	BinaryTreeNode*  m_pRight;
};

//前序遍历递归
void preorder(BinaryTreeNode *T)
{
	if(T == NULL)
		return;
	cout<<T->m_nValue<<endl;
	preorder(T);
}


//二叉树的镜像
void MirrorOfBinaryTree(BinaryTreeNode *pNode)
{
	if(pNode ==NULL)
		return ;
	if(pNode->m_pLeft == NULL  &&  pNode->m_pRight == NULL)
		return;
	/*上面全是边界情况*/

	//交换左右子树
	BinaryTreeNode *pTemp = pNode->m_pLeft;
	pNode->m_pLeft = pNode->m_pRight;
	pNode->m_pRight = pTemp;

	//左递归
	if(pNode->m_pLeft)
		MirrorOfBinaryTree(pNode->m_pLeft);
	//右递归
	if(pNode->m_pRight)
		MirrorOfBinaryTree(pNode->m_pRight);

}

//从上往下打印二叉树   即层序遍历
void PrinttFromTopToBottom(BinaryTreeNode* pTreeRoot) 
{
	if(pTreeRoot == NULL)
		return ;
	
   deque<BinaryTreeNode *> dequeTreeNode;//创建一个双端口队列容器 里面放二叉树节点

	dequeTreeNode.push_back(pTreeRoot); //从队列后面 放入根部节点

	//层序遍列
	while(dequeTreeNode.size())
	{
		BinaryTreeNode *pNode = dequeTreeNode.front();
		dequeTreeNode.pop_front();

		printf("%d", pNode->m_nValue);
		
		if(pNode->m_pLeft)
			dequeTreeNode.push_back(pNode->m_pLeft);
	
		if(pNode->m_pRight)
			dequeTreeNode.push_back(pNode->m_pRight);
	
	}



}








