/**********************************************
 > File Name: singleton.cpp
 > Author: ZY
 > Created Time: 2017年03月22日 星期三 19时01分53秒
*******************************************/

/******************************************************************************
 *教科书里的单例模式
	我们都很清楚一个简单的单例模式该怎样去实现：构造函数声明为private或protect
    防止被外部函数实例化，内部保存一个private static的类指针保存唯一的实例，
    实例的动作由一个public的类方法代劳，该方法也返回单例类唯一的实例。
******************************************************************************/

#include<iostream>

using namespace std;


class singleton
{
	protected:
		singleton(){}
	private:
		static singleton* p;

	public;
		static singleton* instance()
};

singleton* singleton::p = NULL;
singleton* singleton::instance()
{
	if(NULL==p)
		p=new singleton();
	return p;
}


/*************上面的单例不安全  多线程会出错*********
 *2 懒汉与饿汉
　　单例大约有两种实现方法：懒汉与饿汉。
懒汉：故名思义，不到万不得已就不会去实例化类，也就是说在第一次用到类实例的时候
      才会去实例化，所以上边的经典方法被归为懒汉实现；
饿汉：饿了肯定要饥不择食。所以在单例类定义的时候就进行实例化。
特点与选择：
    由于要进行线程同步，所以在访问量比较大，或者可能访问的线程比较多时，采用
    饿汉实现，可以实现更好的性能。这是以空间换时间。
    在访问量较小时，采用懒汉实现。这是以时间换空间。
***********************************************************************/

/************************************************************************
饿汉实现
　　为什么我不讲“线程安全的饿汉实现”？因为饿汉实现本来就是线程安全的，
    不用加锁。为啥？自己想！
****************************************************************************/ 
class singleton
{
	protected:
		singleton(){};
	private:
		static singleton* p;
	public:
		static singleton* instance();
		
};
singleton* singleton::p = new singleton;
singleton* singleton::instance()
{
	return p;
}





























